<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
        <meta name="monetization" content="$ilp.uphold.com/zDFj9FWE4m6e">
        <style>
/*
 DARK: #483D21
 LIGHT: #E5E8D1
 LIGHT SATURATED: #F9FBB2
*/


body {
    user-select: none;
    background-color: #e9e9e1;
    background-image:url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAM9aVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/Pg0KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4zLWMwMTEgNjYuMTQ1NjYxLCAyMDEyLzAyLzA2LTE0OjU2OjI3ICAgICAgICAiPg0KICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPg0KICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzYgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjM4NEI3Q0MyOEExNDExRTdBNjA0RTNCMTA0QkQ4NTU3IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjM4NEI3Q0MzOEExNDExRTdBNjA0RTNCMTA0QkQ4NTU3Ij4NCiAgICAgIDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjM4NEI3Q0MwOEExNDExRTdBNjA0RTNCMTA0QkQ4NTU3IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjM4NEI3Q0MxOEExNDExRTdBNjA0RTNCMTA0QkQ4NTU3IiAvPg0KICAgIDwvcmRmOkRlc2NyaXB0aW9uPg0KICA8L3JkZjpSREY+DQo8L3g6eG1wbWV0YT4NCjw/eHBhY2tldCBlbmQ9InIiPz7DjRUZAAAAOElEQVQ4T2O8d+8eAyWACUqTDahrwKePH/+DMJRLFKCuC/j4+RlBGMolCgyyQCQHjBowDAxgYAAAieQKuj4KC0oAAAAASUVORK5CYII=');
    font-family: 'Courier New', Courier, monospace;
    overflow: hidden;
}

.hide {
    display: none !important;
}

.spacebar {
    display: inline !important;
    background: rgb(239,242,221);
    background: linear-gradient(180deg, rgba(239,242,221,1) 0%, rgba(177,180,149,1) 100%);
    border: 2px solid #483D21;
    border-bottom-width: 5px;
    color: #483D21;
    border-radius: 4px;
    padding: 0px;
    padding-right: 30px;
    margin-right: 5px;
}

#game {
    max-width: 1000px;
    margin: auto;
    overflow: hidden;
}

#footer {
    position: fixed;
    padding: 5px;
    left: 0;
    bottom: 0;
    width: 100%;
    background-color: #483D21;
    color: #F9FBB2;
    text-align: center;
    font-size: .8rem;
}

#footer a {
    color: #F9FBB2;
}

#counter {
    text-align: center;
    font-size: 8rem;
    color: #483D21;
    height: 8rem;
    font-weight: bold;
}

#counter span {
    display: block;
    text-align: center;
}

#per_second {
    font-size: 1.5rem;
    text-align: center;
    margin-bottom: 1rem;
    color: #483D21;
}

.sbs {
    display: block;
    font-size: 1.2rem;
    color: #FFF;
    text-align: center;
    text-decoration: none;
    font-weight: bold;
    letter-spacing: 15px;
    padding-top: 40px;
    padding-bottom: 10px;
}

.sb1 {
    border: 5px solid #483D21;
    border-bottom-width: 25px;
    color: #8a7d5a;
    border-radius: 15px;
    transition: transform 80ms ease-in;
    
    background: rgb(239,242,221);
    background: linear-gradient(180deg, rgba(239,242,221,1) 0%, rgba(177,180,149,1) 100%);
}

.sb1:hover {
    transition: transform 80ms ease-in;
    color: #483D21;
}

.sb1:active, .sb_active {
    border-color: #483D21;
    border-bottom-width: 15px;
    padding-top: 50px;
    transform: scaleX(90%) scaleY(90%);
    transition: transform 10ms ease-in;
}

/* Items */

#items {
    margin-bottom: 0;
    list-style: none;
    margin-bottom: 0;
    margin-top: 1rem;
    padding: 10px;
    overflow-y: auto;
}

.item {
    display: block;
    border: 1px solid #483D21;
    border-radius: 5px;
    margin: 0;
    margin-bottom: 15px;
    padding: 15px;
    opacity: .5;
    background-color: #e9e9e1;
}

.item_last_child {
    margin-bottom: 80px;
}

.item span {
    display: block;
}

.item_buyable {
    opacity: 1.0;
    background: rgb(252,255,229);
    background: linear-gradient(180deg, rgba(252,255,229,1) 0%, rgba(229,232,209,1) 100%);
}

.item_buyable:hover {
    background: rgb(254,255,219);
    background: linear-gradient(180deg, rgba(254,255,219,1) 0%, rgba(249,251,178,1) 100%);
}

.item_buyable:active {
    background: rgb(223,227,192);
    background: linear-gradient(180deg, rgba(223,227,192,1) 0%, rgba(183,186,156,1) 100%);
}

.ititle {
    font-size: 1.5rem;
    margin-top: 0;
}

.idesc {
    font-size: 1rem;
}

.cost {
    margin-top: 15px;
}

.icost {
    display: inline !important;
}

.ilvl {
    margin-top: 0;
    font-size: 3rem;
    float: right;
    margin-top: auto;
    margin-bottom: auto;
}

._ilvl {
    display: inline !important;
    font-size: 1rem;
}

/* Particles */
.particle {
    width: auto;
    position: absolute;
    pointer-events: none;
    left: 0;
    right: 0;
}

.score {
    font-weight: bold;
    font-size: 1.3rem;
    color: 483D21;
    z-index: 100;
}

.spacebar_particle {
    pointer-events: none;
    position: absolute;
    left: 0;
    top: 0;
    z-index: -100;

    width: 5px;
    height: 15px;
}

</style>
        
        <title>SPACEBAR CLICKER</title>
    </head>
    <body>
        <div id="game">
            <div id="header">
                <div id="counter"><span>0</span></div>
                <div id="per_second">0</div>
                <div class="sbc">
                    <div id="sb" class="sbs sb1">SPACEBAR</div>
                </div>
            </div>
            <ul id="items">
                <li id="it" class="item">
                    <span class="ilvl">%4</span>
                    <h1 class="ititle">%1</h1>
                    <span class="idesc">%2</span>
                    <div class="cost"><span class="spacebar"></span><span class="icost">%3</span></div>
                </li>
            </ul>
        </div>
        <div id="footer">a game by <a href="https://bruno.croci.me/">CrociDB</a> | <a href="javascript:game.resetGameSure();">reset game</a></div>


        <!-- Scripts -->
        <script>
/**
 * SfxrParams
 *
 * Copyright 2010 Thomas Vian
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @author Thomas Vian
 */
/** @constructor */
function SfxrParams() {
    //--------------------------------------------------------------------------
    //
    //  Settings String Methods
    //
    //--------------------------------------------------------------------------
  
    /**
     * Parses a settings array into the parameters
     * @param array Array of the settings values, where elements 0 - 23 are
     *                a: waveType
     *                b: attackTime
     *                c: sustainTime
     *                d: sustainPunch
     *                e: decayTime
     *                f: startFrequency
     *                g: minFrequency
     *                h: slide
     *                i: deltaSlide
     *                j: vibratoDepth
     *                k: vibratoSpeed
     *                l: changeAmount
     *                m: changeSpeed
     *                n: squareDuty
     *                o: dutySweep
     *                p: repeatSpeed
     *                q: phaserOffset
     *                r: phaserSweep
     *                s: lpFilterCutoff
     *                t: lpFilterCutoffSweep
     *                u: lpFilterResonance
     *                v: hpFilterCutoff
     *                w: hpFilterCutoffSweep
     *                x: masterVolume
     * @return If the string successfully parsed
     */
    this.setSettings = function(values)
    {
      for ( var i = 0; i < 24; i++ )
      {
        this[String.fromCharCode( 97 + i )] = values[i] || 0;
      }
  
      // I moved this here from the reset(true) function
      if (this['c'] < .01) {
        this['c'] = .01;
      }
  
      var totalTime = this['b'] + this['c'] + this['e'];
      if (totalTime < .18) {
        var multiplier = .18 / totalTime;
        this['b']  *= multiplier;
        this['c'] *= multiplier;
        this['e']   *= multiplier;
      }
    }
  }
  
  /**
   * SfxrSynth
   *
   * Copyright 2010 Thomas Vian
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * @author Thomas Vian
   */
  /** @constructor */
  function SfxrSynth() {
    // All variables are kept alive through function closures
  
    //--------------------------------------------------------------------------
    //
    //  Sound Parameters
    //
    //--------------------------------------------------------------------------
  
    this._params = new SfxrParams();  // Params instance
  
    //--------------------------------------------------------------------------
    //
    //  Synth Variables
    //
    //--------------------------------------------------------------------------
  
    var _envelopeLength0, // Length of the attack stage
        _envelopeLength1, // Length of the sustain stage
        _envelopeLength2, // Length of the decay stage
  
        _period,          // Period of the wave
        _maxPeriod,       // Maximum period before sound stops (from minFrequency)
  
        _slide,           // Note slide
        _deltaSlide,      // Change in slide
  
        _changeAmount,    // Amount to change the note by
        _changeTime,      // Counter for the note change
        _changeLimit,     // Once the time reaches this limit, the note changes
  
        _squareDuty,      // Offset of center switching point in the square wave
        _dutySweep;       // Amount to change the duty by
  
    //--------------------------------------------------------------------------
    //
    //  Synth Methods
    //
    //--------------------------------------------------------------------------
  
    /**
     * Resets the runing variables from the params
     * Used once at the start (total reset) and for the repeat effect (partial reset)
     */
    this.reset = function() {
      // Shorter reference
      var p = this._params;
  
      _period       = 100 / (p['f'] * p['f'] + .001);
      _maxPeriod    = 100 / (p['g']   * p['g']   + .001);
  
      _slide        = 1 - p['h'] * p['h'] * p['h'] * .01;
      _deltaSlide   = -p['i'] * p['i'] * p['i'] * .000001;
  
      if (!p['a']) {
        _squareDuty = .5 - p['n'] / 2;
        _dutySweep  = -p['o'] * .00005;
      }
  
      _changeAmount =  1 + p['l'] * p['l'] * (p['l'] > 0 ? -.9 : 10);
      _changeTime   = 0;
      _changeLimit  = p['m'] == 1 ? 0 : (1 - p['m']) * (1 - p['m']) * 20000 + 32;
    }
  
    // I split the reset() function into two functions for better readability
    this.totalReset = function() {
      this.reset();
  
      // Shorter reference
      var p = this._params;
  
      // Calculating the length is all that remained here, everything else moved somewhere
      _envelopeLength0 = p['b']  * p['b']  * 100000;
      _envelopeLength1 = p['c'] * p['c'] * 100000;
      _envelopeLength2 = p['e']   * p['e']   * 100000 + 12;
      // Full length of the volume envelop (and therefore sound)
      // Make sure the length can be divided by 3 so we will not need the padding "==" after base64 encode
      return ((_envelopeLength0 + _envelopeLength1 + _envelopeLength2) / 3 | 0) * 3;
    }
  
    /**
     * Writes the wave to the supplied buffer ByteArray
     * @param buffer A ByteArray to write the wave to
     * @return If the wave is finished
     */
    this.synthWave = function(buffer, length) {
      // Shorter reference
      var p = this._params;
  
      // If the filters are active
      var _filters = p['s'] != 1 || p['v'],
          // Cutoff multiplier which adjusts the amount the wave position can move
          _hpFilterCutoff = p['v'] * p['v'] * .1,
          // Speed of the high-pass cutoff multiplier
          _hpFilterDeltaCutoff = 1 + p['w'] * .0003,
          // Cutoff multiplier which adjusts the amount the wave position can move
          _lpFilterCutoff = p['s'] * p['s'] * p['s'] * .1,
          // Speed of the low-pass cutoff multiplier
          _lpFilterDeltaCutoff = 1 + p['t'] * .0001,
          // If the low pass filter is active
          _lpFilterOn = p['s'] != 1,
          // masterVolume * masterVolume (for quick calculations)
          _masterVolume = p['x'] * p['x'],
          // Minimum frequency before stopping
          _minFreqency = p['g'],
          // If the phaser is active
          _phaser = p['q'] || p['r'],
          // Change in phase offset
          _phaserDeltaOffset = p['r'] * p['r'] * p['r'] * .2,
          // Phase offset for phaser effect
          _phaserOffset = p['q'] * p['q'] * (p['q'] < 0 ? -1020 : 1020),
          // Once the time reaches this limit, some of the    iables are reset
          _repeatLimit = p['p'] ? ((1 - p['p']) * (1 - p['p']) * 20000 | 0) + 32 : 0,
          // The punch factor (louder at begining of sustain)
          _sustainPunch = p['d'],
          // Amount to change the period of the wave by at the peak of the vibrato wave
          _vibratoAmplitude = p['j'] / 2,
          // Speed at which the vibrato phase moves
          _vibratoSpeed = p['k'] * p['k'] * .01,
          // The type of wave to generate
          _waveType = p['a'];
  
      var _envelopeLength      = _envelopeLength0,     // Length of the current envelope stage
          _envelopeOverLength0 = 1 / _envelopeLength0, // (for quick calculations)
          _envelopeOverLength1 = 1 / _envelopeLength1, // (for quick calculations)
          _envelopeOverLength2 = 1 / _envelopeLength2; // (for quick calculations)
  
      // Damping muliplier which restricts how fast the wave position can move
      var _lpFilterDamping = 5 / (1 + p['u'] * p['u'] * 20) * (.01 + _lpFilterCutoff);
      if (_lpFilterDamping > .8) {
        _lpFilterDamping = .8;
      }
      _lpFilterDamping = 1 - _lpFilterDamping;
  
      var _finished = false,     // If the sound has finished
          _envelopeStage    = 0, // Current stage of the envelope (attack, sustain, decay, end)
          _envelopeTime     = 0, // Current time through current enelope stage
          _envelopeVolume   = 0, // Current volume of the envelope
          _hpFilterPos      = 0, // Adjusted wave position after high-pass filter
          _lpFilterDeltaPos = 0, // Change in low-pass wave position, as allowed by the cutoff and damping
          _lpFilterOldPos,       // Previous low-pass wave position
          _lpFilterPos      = 0, // Adjusted wave position after low-pass filter
          _periodTemp,           // Period modified by vibrato
          _phase            = 0, // Phase through the wave
          _phaserInt,            // Integer phaser offset, for bit maths
          _phaserPos        = 0, // Position through the phaser buffer
          _pos,                  // Phase expresed as a Number from 0-1, used for fast sin approx
          _repeatTime       = 0, // Counter for the repeats
          _sample,               // Sub-sample calculated 8 times per actual sample, averaged out to get the super sample
          _superSample,          // Actual sample writen to the wave
          _vibratoPhase     = 0; // Phase through the vibrato sine wave
  
      // Buffer of wave values used to create the out of phase second wave
      var _phaserBuffer = new Array(1024),
          // Buffer of random values used to generate noise
          _noiseBuffer  = new Array(32);
      for (var i = _phaserBuffer.length; i--; ) {
        _phaserBuffer[i] = 0;
      }
      for (var i = _noiseBuffer.length; i--; ) {
        _noiseBuffer[i] = Math.random() * 2 - 1;
      }
  
      for (var i = 0; i < length; i++) {
        if (_finished) {
          return i;
        }
  
        // Repeats every _repeatLimit times, partially resetting the sound parameters
        if (_repeatLimit) {
          if (++_repeatTime >= _repeatLimit) {
            _repeatTime = 0;
            this.reset();
          }
        }
  
        // If _changeLimit is reached, shifts the pitch
        if (_changeLimit) {
          if (++_changeTime >= _changeLimit) {
            _changeLimit = 0;
            _period *= _changeAmount;
          }
        }
  
        // Acccelerate and apply slide
        _slide += _deltaSlide;
        _period *= _slide;
  
        // Checks for frequency getting too low, and stops the sound if a minFrequency was set
        if (_period > _maxPeriod) {
          _period = _maxPeriod;
          if (_minFreqency > 0) {
            _finished = true;
          }
        }
  
        _periodTemp = _period;
  
        // Applies the vibrato effect
        if (_vibratoAmplitude > 0) {
          _vibratoPhase += _vibratoSpeed;
          _periodTemp *= 1 + Math.sin(_vibratoPhase) * _vibratoAmplitude;
        }
  
        _periodTemp |= 0;
        if (_periodTemp < 8) {
          _periodTemp = 8;
        }
  
        // Sweeps the square duty
        if (!_waveType) {
          _squareDuty += _dutySweep;
          if (_squareDuty < 0) {
            _squareDuty = 0;
          } else if (_squareDuty > .5) {
            _squareDuty = .5;
          }
        }
  
        // Moves through the different stages of the volume envelope
        if (++_envelopeTime > _envelopeLength) {
          _envelopeTime = 0;
  
          switch (++_envelopeStage)  {
            case 1:
              _envelopeLength = _envelopeLength1;
              break;
            case 2:
              _envelopeLength = _envelopeLength2;
          }
        }
  
        // Sets the volume based on the position in the envelope
        switch (_envelopeStage) {
          case 0:
            _envelopeVolume = _envelopeTime * _envelopeOverLength0;
            break;
          case 1:
            _envelopeVolume = 1 + (1 - _envelopeTime * _envelopeOverLength1) * 2 * _sustainPunch;
            break;
          case 2:
            _envelopeVolume = 1 - _envelopeTime * _envelopeOverLength2;
            break;
          case 3:
            _envelopeVolume = 0;
            _finished = true;
        }
  
        // Moves the phaser offset
        if (_phaser) {
          _phaserOffset += _phaserDeltaOffset;
          _phaserInt = _phaserOffset | 0;
          if (_phaserInt < 0) {
            _phaserInt = -_phaserInt;
          } else if (_phaserInt > 1023) {
            _phaserInt = 1023;
          }
        }
  
        // Moves the high-pass filter cutoff
        if (_filters && _hpFilterDeltaCutoff) {
          _hpFilterCutoff *= _hpFilterDeltaCutoff;
          if (_hpFilterCutoff < .00001) {
            _hpFilterCutoff = .00001;
          } else if (_hpFilterCutoff > .1) {
            _hpFilterCutoff = .1;
          }
        }
  
        _superSample = 0;
        for (var j = 8; j--; ) {
          // Cycles through the period
          _phase++;
          if (_phase >= _periodTemp) {
            _phase %= _periodTemp;
  
            // Generates new random noise for this period
            if (_waveType == 3) {
              for (var n = _noiseBuffer.length; n--; ) {
                _noiseBuffer[n] = Math.random() * 2 - 1;
              }
            }
          }
  
          // Gets the sample from the oscillator
          switch (_waveType) {
            case 0: // Square wave
              _sample = ((_phase / _periodTemp) < _squareDuty) ? .5 : -.5;
              break;
            case 1: // Saw wave
              _sample = 1 - _phase / _periodTemp * 2;
              break;
            case 2: // Sine wave (fast and accurate approx)
              _pos = _phase / _periodTemp;
              _pos = (_pos > .5 ? _pos - 1 : _pos) * 6.28318531;
              _sample = 1.27323954 * _pos + .405284735 * _pos * _pos * (_pos < 0 ? 1 : -1);
              _sample = .225 * ((_sample < 0 ? -1 : 1) * _sample * _sample  - _sample) + _sample;
              break;
            case 3: // Noise
              _sample = _noiseBuffer[Math.abs(_phase * 32 / _periodTemp | 0)];
          }
  
          // Applies the low and high pass filters
          if (_filters) {
            _lpFilterOldPos = _lpFilterPos;
            _lpFilterCutoff *= _lpFilterDeltaCutoff;
            if (_lpFilterCutoff < 0) {
              _lpFilterCutoff = 0;
            } else if (_lpFilterCutoff > .1) {
              _lpFilterCutoff = .1;
            }
  
            if (_lpFilterOn) {
              _lpFilterDeltaPos += (_sample - _lpFilterPos) * _lpFilterCutoff;
              _lpFilterDeltaPos *= _lpFilterDamping;
            } else {
              _lpFilterPos = _sample;
              _lpFilterDeltaPos = 0;
            }
  
            _lpFilterPos += _lpFilterDeltaPos;
  
            _hpFilterPos += _lpFilterPos - _lpFilterOldPos;
            _hpFilterPos *= 1 - _hpFilterCutoff;
            _sample = _hpFilterPos;
          }
  
          // Applies the phaser effect
          if (_phaser) {
            _phaserBuffer[_phaserPos % 1024] = _sample;
            _sample += _phaserBuffer[(_phaserPos - _phaserInt + 1024) % 1024];
            _phaserPos++;
          }
  
          _superSample += _sample;
        }
  
        // Averages out the super samples and applies volumes
        _superSample *= .125 * _envelopeVolume * _masterVolume;
  
        // Clipping if too loud
        buffer[i] = _superSample >= 1 ? 32767 : _superSample <= -1 ? -32768 : _superSample * 32767 | 0;
      }
  
      return length;
    }
  }
  
  // Adapted from http://codebase.es/riffwave/
  var synth = new SfxrSynth();
  // Export for the Closure Compiler
  window['jsfxr'] = function(settings) {
    // Initialize SfxrParams
    synth._params.setSettings(settings);
    // Synthesize Wave
    var envelopeFullLength = synth.totalReset();
    var data = new Uint8Array(((envelopeFullLength + 1) / 2 | 0) * 4 + 44);
    var used = synth.synthWave(new Uint16Array(data.buffer, 44), envelopeFullLength) * 2;
    var dv = new Uint32Array(data.buffer, 0, 44);
    // Initialize header
    dv[0] = 0x46464952; // "RIFF"
    dv[1] = used + 36;  // put total size here
    dv[2] = 0x45564157; // "WAVE"
    dv[3] = 0x20746D66; // "fmt "
    dv[4] = 0x00000010; // size of the following
    dv[5] = 0x00010001; // Mono: 1 channel, PCM format
    dv[6] = 0x0000AC44; // 44,100 samples per second
    dv[7] = 0x00015888; // byte rate: two bytes per sample
    dv[8] = 0x00100002; // 16 bits per sample, aligned on every two bytes
    dv[9] = 0x61746164; // "data"
    dv[10] = used;      // put number of samples here
  
    // Base64 encoding written by me, @maettig
    used += 44;
    var i = 0,
        base64Characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
        output = 'data:audio/wav;base64,';
    for (; i < used; i += 3)
    {
      var a = data[i] << 16 | data[i + 1] << 8 | data[i + 2];
      output += base64Characters[a >> 18] + base64Characters[a >> 12 & 63] + base64Characters[a >> 6 & 63] + base64Characters[a & 63];
    }
    return output;
  }
  
</script>
        <script>
// DOM utils
const gId = t => document.getElementById(t);
const qSel = t => document.querySelector(t);
const qSelA = t => document.querySelectorAll(t);
const cEl = s => {
    let template = document.createElement("template");
    template.innerHTML = s;
    return template.content.firstChild;
};

// Text utils
const repltxt = (t, vs) => {
    vs.forEach((e, i) => t = t.replace("%" + (i+1), e));
    return t;
};

// Math utils
const clamp = (val, min, max) => Math.min(Math.max(val, min), max);
const clamp01 = (val) => clamp(val, 0, 1);
const lerp = (a, b, t) => a + (b - a) * clamp01(t);

// Number utils
const NUBMER_FORMATS = ['M', 'B', 'T', 'Q', 'Qui', 'S', 'Sp']

const fmt = (value, f) => { return (f + value).slice(-f.length); };
const nfmt = (v) => Math.floor(v).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
const nfmt1 = (v) => v.toFixed(3).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
const nfmt2 = (v) => {
    if (v < 1000000) {
        return nfmt(v);
    }

    let nv = 1000000;
    for (let i in NUBMER_FORMATS)
    {
        nv *= 1000;
        if (v < nv) {
            return nfmt1(v / (nv / 1000)) + NUBMER_FORMATS[i];
        }
    }
}

// Randoms
const randnum = (v = 1) => Math.random() * v;
const randint = (v) => Math.round(randnum(v));
const randsig = () => randint(10) % 2 == 0 ? 1 : -1;
const randweight = (c, p) => {
    let sum = c.map(p).reduce((l, r) => l + r);
    let rand = randint(sum);   
    return c.filter(e => {
        rand = rand - p(e);
        return rand <= 0;
    })[0];
};
const randweightsqrd = (c, p) => randweight(c, v => p(v) * p(v));

// Coroutine
const co = (f) => {
    let g = f();

    const next = () => {
        let result = g.next();
        if (!result.done) {
            setTimeout(next, result.value * 1000);
        }
    };

    next();
};

// Mobile
const mobile = () => navigator.userAgent.match("Mobile");

// Audio stuff
const audio_player = [new Audio(), new Audio()];
let audio_index = 0;
let AUDIO = true;
const playaudio = (a) => {
    if (AUDIO) {
        audio_index = (audio_index + 1) % audio_player.length;

        audio_player[audio_index].pause();
        audio_player[audio_index].src = a[Math.floor(Math.random() * a.length)];
        audio_player[audio_index].play();
    }
};

</script>
        <script>
let ITEMS = [
    {
        name: "Monkey",
        description: "A monkey to help you press space. It doesn't really know what a <i>spacebar</i> is, so it will just bash the whole keyboard and eventually hit it. It succeeds every <b>%v seconds</b>.",
        cost: 30,
        initial_value: .2,
        lvl: 0,
        cost_func: (x) => 1.1 * x,
        value_func: (x) => x,
        getDescription: (it) => it.description.replace("%v", 1.0 / it.initial_value),
    },
    {
        name: "Boomer Mom",
        description: "A boomer mom who can't barely open a Word document to help you press it. Every mom can press it <b>%vx a second</b>!",
        cost: 120,
        initial_value: 3,
        lvl: 0,
        cost_func: (x) => 1.3 * x,
        value_func: (x) => 1.0 * x,
        getDescription: (it) => it.description.replace("%v", nfmt(it.value)),
    },
    {
        name: "Gen Z Kid",
        description: "A Generation Z kid will help you press it. They haven't ever seen a keyboard before, but they're good at scrolling short vertical videos online, so they do it <b>%vx a second</b>!",
        cost: 500,
        initial_value: 20,
        lvl: 0,
        cost_func: (x) => 1.4 * x,
        value_func: (x) => 1.0 * x,
        getDescription: (it) => it.description.replace("%v", nfmt(it.value)),
    },
    {
        name: "Keyboard Upgrade",
        description: "Every upgrade will <b>DOUBLE</b> your own hits.",
        cost: 6000,
        multiplier: 2,
        lvl: 0,
        cost_func: (x) => 3.5 * x,
        getDescription: (it) => it.description,
    },
    {
        name: "Angry Influencer",
        description: "Angry influencer whose computer crashed and they're now bashing their heads against the keyboard. The more influencer you get, the faster they can hit it, because they can't stand competition. The next one will give <b>%vx per second</b>.",
        cost: 10000,
        initial_value: 150,
        lvl: 0,
        cost_func: (x) => 1.5 * x,
        value_func: (x) => 1.2 * x,
        getDescription: (it) => it.description.replace("%v", nfmt(it.value)),
    },
    {
        name: "MOBA Gamer",
        description: "MOBA gamers are fast at pressing keys and they play well in teams. New gamer will hit it <b>%vx per second</b>.",
        cost: 200000,
        initial_value: 600,
        lvl: 0,
        cost_func: (x) => 1.4 * x,
        value_func: (x) => 1.25 * x,
        getDescription: (it) => it.description.replace("%v", nfmt(it.value)),
    },
    {
        name: "Homemade Pressing Robot",
        description: "Just a simple robot made out of a broken robot vacuum cleaner that can press the key at the impressive rate of <b>%vx per second</b>!",
        cost: 800000,
        initial_value: 3500,
        lvl: 0,
        cost_func: (x) => 1.4 * x,
        value_func: (x) => 1.25 * x,
        getDescription: (it) => it.description.replace("%v", nfmt(it.value)),
    },
    {
        name: "Laser Machine Gun",
        description: "A machine gun that shoots a lot of laser blasts at the spacebar, at a rate of <b>%vx per second</b>!",
        cost: 2000000,
        initial_value: 25000,
        lvl: 0,
        cost_func: (x) => 1.4 * x,
        value_func: (x) => 1.3 * x,
        getDescription: (it) => it.description.replace("%v", nfmt(it.value)),
    },
    {
        name: "Nuclear Blast Gun",
        description: "No one knows how it works except for the girl that created it. But the rate is pretty high at <b>%vx per second</b>!",
        cost: 10000000,
        initial_value: 100000,
        lvl: 0,
        cost_func: (x) => 1.4 * x,
        value_func: (x) => 1.3 * x,
        getDescription: (it) => it.description.replace("%v", nfmt(it.value)),
    },
    {
        name: "Alien Tech Key Pressing Machine",
        description: "No one knows how it works except for the girl that created it. But the rate is pretty high at <b>%vx per second</b>!",
        cost: 80000000,
        initial_value: 1000000,
        lvl: 0,
        cost_func: (x) => 1.4 * x,
        value_func: (x) => 1.3 * x,
        getDescription: (it) => it.description.replace("%v", nfmt(it.value)),
    },
];

(function() {
    for (let i in ITEMS) {
        ITEMS[i].value = ITEMS[i].initial_value;
    }
})();

let total_item_value = (item) => {
    let c = 0;
    let v = item.initial_value;

    for (let i = 0; i < item.lvl; i++) {
        c += v;
        v = item.value_func(v);
    }

    return c;
}

let LEVELS = [
    {
        psvalue: 0,
        rain: 0,
    },
    {
        psvalue: 10,
        rain: 5,
    },
    {
        psvalue: 100,
        rain: 10,
    },
    {
        psvalue: 500,
        rain: 12,
    },
    {
        psvalue: 1000,
        rain: 15,
    },
    {
        psvalue: 5000,
        rain: 17,
    },
    {
        psvalue: 10000,
        rain: 18,
    },
    {
        psvalue: 50000,
        rain: 19,
    },
    {
        psvalue: 100000,
        rain: 20,
    },
    {
        psvalue: 300000,
        rain: 21,
    },
    {
        psvalue: 800000,
        rain: 22,
    },
    {
        psvalue: 1000000,
        rain: 23,
    },
];

const SOUNDS = {
    click: [
        jsfxr([0,0,0.07086974935991196,0.45065582613048494,0.12451125371771453,0.6610070860477287,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0.5]),
        jsfxr([0,0,0.07086974935991196,0.35,0.12451125371771453,0.7,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0.5]),
        jsfxr([0,0,0.1,0.35,0.12451125371771453,0.65,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0.5]),
    ],
    buy: [
        jsfxr([3,0,0.2914228463087029,0.39443991332966943,0.47848602130372286,0.08144714074126518,0,0.24222569085835757,0,0,0,-0.6369038513918057,0.7915717139323191,0,0,0,0,0,1,0,0,0,0,0.5]),
        jsfxr([3,0,0.2914228463087029,0.39443991332966943,0.55,0.15,0,0.24222569085835757,0,0,0,-0.6369038513918057,0.7915717139323191,0,0,0,0,0,1,0,0,0,0,0.5]),
        jsfxr([3,0,0.25,0.39443991332966943,0.45,0.25,0,0.24222569085835757,0,0,0,-0.6369038513918057,0.7915717139323191,0,0,0,0,0,1,0,0,0,0,0.5]),
    ],
};

</script>
        <script>
class ParticleSystem {
    constructor(lifetime, func) {
        this.lifetime = lifetime;
        this.func = func;
        this.particles = [];
        setInterval(this.update.bind(this), 16);
    }

    pushParticle(domElement, pos) {
        this.particles.push({
            life: this.lifetime,
            element: domElement,
            x: pos.x,
            y: pos.y,
            ix: pos.x,
            iy: pos.y,
            alpha: 0,
            rot: 0
        });
        domElement.style['opacity'] = "0";
    }

    update() {
        let remove = [];
        for (let i in this.particles) {
            let p = this.particles[i];
            p.life -= 0.016;
            p.normalized_time = 1.0 - p.life / this.lifetime;
            this.func(p);
            p.element.style['transform'] = "translateX(" + p.x + "px) translateY(" + p.y + "px) rotateZ(" + p.rot + "deg)";
            p.element.style['opacity'] = "" + (1.0 - p.alpha);
            
            if (p.life <= 0) remove.push(i);
        }
        
        for (let j in remove) {
            this.particles[remove[j]].element.remove();
            this.particles.splice(remove[j], 1);
        }
    }
}
</script>
        <script>
class Counter {
    constructor() {
        this.v = 0;
        this.va = 0;
        this.multiplier = 1;

        setInterval(this.update.bind(this), 10);
    }

    evaluateItems() {
        this.va = 0;
        this.multiplier = 1;
        for (let i in ITEMS) {
            let it = ITEMS[i];
            if (it.multiplier != undefined)
                this.multiplier *= it.lvl > 0 ? Math.pow(it.multiplier, it.lvl) : 1;
            else
                this.va += total_item_value(it);
        }
    }

    update() {
        this.v += this.va / 100; // divides by 100 because values are per seconds it runs every 0.01 seconds.
    }

    setValue(v) {
        this.v = v;
    }

    spend(v) {
        this.v -= v;
    }

    add(v) {
        let val = v * this.multiplier;
        this.v += val;
        return val;
    }

    addOne() {
        this.v += this.multiplier;
        return this.multiplier;
    }
}
</script>
        <script>
class Game {
    constructor() {
        
    }

    init() {
        this.currentLevel = 0;

        // Counter
        this.cc = gId("counter");
        this.cs = gId("per_second");
        this.counter = new Counter();

        // Key button
        this.sb = gId("sb");
        this.sb.addEventListener("mousedown", this.click.bind(this));
        document.addEventListener("keydown", this.keydown.bind(this));
        document.addEventListener("keyup", this.keyup.bind(this));
        document.setValue = this.setValue.bind(this);

        // Particles
        this.click_particle = new ParticleSystem(1.0, (p) => { 
            p.y = lerp(p.y, p.iy - 110, 0.05); 
            p.x = p.ix + Math.sin((p.ix * 5 + p.normalized_time) * 10) * 10;
            p.alpha = p.normalized_time;
        });

        this.rain_particle = new ParticleSystem(3.0, (p) => { 
            p.y += 3; 
            p.x = p.ix + Math.sin((p.ix * 5 + p.normalized_time) * 10) * 10;
            p.rot = Math.sin(p.normalized_time * 30) * 10;
            p.alpha = p.normalized_time;
        });
        
        // Items
        this.items = [];
        this.item_container = gId("items");
        let item_template = gId("it");
        for (let i in ITEMS) {
            let it = ITEMS[i];
            let html = item_template.innerHTML
            .replace("%1", it.name)
            .replace("%2", it.getDescription(it))
            .replace("%3", it.cost)
            .replace("%4", it.lvl);

            let e = document.createElement("li");
            e.classList.add("item");
            e.innerHTML = html;
            this.item_container.appendChild(e);
            it.dyn_element = e;
            e.addEventListener("click", this.buy.bind(this, it));
        }
        this.item_container.removeChild(item_template);
        this.adjustSize();
        window.addEventListener("resize", this.adjustSize.bind(this));

        this.loadGame();
        this.updateItemDescriptions();
        this.counter.evaluateItems();
        this.checkCurrentLevel();
        this.update();

        setInterval(this.update.bind(this), 100);
        this.frameCounter = 0;
    }

    adjustSize() {
        if (mobile()) {
            this.cc.style['font-size'] = (8 - (this.cc.innerText.length / 2)) + "rem";
        } else {
            this.cc.style['font-size'] = (10 - (this.cc.innerText.length / 3)) + "rem";
        }

        let size = (this.cc.clientHeight - this.cc.firstChild.clientHeight) / 2;
        this.cc.firstChild.style['transform'] = "translateY(" + size + "px)"

        this.item_container.style['height'] = (window.innerHeight - gId("header").offsetHeight) + "px";
    }

    update() {
        this.updateCounter();
        this.updateItems();
        this.updateParticles();
        this.adjustSize();

        this.saveGame();
    }
    
    updateItems() {
        let lastBought = 0;
        for (let i in ITEMS) {
            let it = ITEMS[i];

            if (it.lvl > 0) lastBought = parseInt(i) + 1;

            it.dyn_element.classList.add("hide");
            it.dyn_element.classList.remove("item_buyable");
            it.dyn_element.getElementsByClassName("icost")[0].innerHTML = nfmt2(it.cost);
            it.dyn_element.getElementsByClassName("ilvl")[0].innerHTML = '<span class="_ilvl">x</span>' + it.lvl;
            it.dyn_element.classList.remove("item_last_child");

            if (it.cost <= this.counter.v) {
                it.dyn_element.classList.add("item_buyable");
            }
        }
        
        let last_item = null;
        if (this.counter.v > 9 || this.counter.va > 0)
        {
            for (let i = 0; i < Math.min(ITEMS.length, lastBought + 1); i++) {
                let it = ITEMS[i];
                it.dyn_element.classList.remove("hide");
                last_item = it.dyn_element;
            }
        }

        if (last_item != null) last_item.classList.add("item_last_child");
    }

    updateItemDescriptions() {
        for (let i in ITEMS) {
            let it = ITEMS[i];

            it.dyn_element.querySelector('.idesc').innerHTML = it.getDescription(it);
        }
    }
    
    updateCounter() {
        this.cc.firstChild.innerText = nfmt2(this.counter.v);
        this.cs.innerHTML = "per second: " + (this.counter.va < 1000 ? nfmt1(this.counter.va) : nfmt2(this.counter.va));
    }

    updateParticles() {
        let lvl = LEVELS[this.currentLevel];
        if (lvl.rain > 0) {
            if (this.frameCounter % (21 - clamp(lvl.rain, 0, 20)) == 0) {
                for (let i = 0; i < Math.floor(lvl.rain / 21) + 1; i++) {
                    let x = Math.random() * window.innerWidth;
                    let y = 0;
        
                    let element = document.createElement('div');
                    element.classList.add("spacebar");
                    element.classList.add("spacebar_particle");
                    this.rain_particle.pushParticle(element, { x: x, y: y});
                    document.body.insertBefore(element, document.body.firstChild);
                }
            }
        }

        this.frameCounter++;
    }

    buy(it) {
        if (this.counter.v < it.cost) return;

        playaudio(SOUNDS.buy); 

        this.counter.spend(Math.floor(it.cost));
        it.lvl++;
        it.cost = it.cost_func(it.cost);
        
        if (it.initial_value != undefined)
            it.value = it.value == undefined ? it.value_func(it.initial_value) : it.value_func(it.value);

        this.counter.evaluateItems();
        this.updateItemDescriptions();

        this.checkCurrentLevel();
        this.update();
        this.shake();
    }

    checkCurrentLevel() {
        for (let i in LEVELS) {
            let lvl = LEVELS[i];
            if (this.counter.va > lvl.psvalue) {
                this.currentLevel = i;
            }
        }
    }
    
    setValue(v) {
        this.counter.setValue(v);
        this.update();
    }

    click(e) {
        let val = this.counter.addOne();
        this.updateCounter();
        playaudio(SOUNDS.click); 

        if (e == undefined) {
            let b = this.sb.getBoundingClientRect(); 
            let r = Math.random() * 50 - 25;
            this.addPointParticle(b.right - (b.width / 2) + r, b.top, val);
        } else {
            this.addPointParticle(e.clientX, e.clientY, val);
        }
    }
    
    keydown(e) {
        if (e.code == "Space" && this.canclick) {
            this.click();
            sb.classList.add("sb_active");
            this.canclick = false;
        }
    }
     
    keyup(e) {
        if (e.code == "Space") {
            this.sb.classList.remove("sb_active");
            this.canclick = true;
        }
    }

    // Load/Save
    resetGameSure() {
        if (window.confirm("Are you sure you want to reset all the game data?")) {
            this.resetGame();
        }
    }

    resetGame() {
        this.reloading = true;
        window.localStorage.removeItem("spacebar_clicker_game");
        window.location.reload(true);
    }

    loadGame() {
        let savegamestr = window.localStorage.getItem("spacebar_clicker_game");
        if (savegamestr == undefined || savegamestr == null) return;

        let savedata = JSON.parse(savegamestr);
        if (savedata.empty) return;

        console.dir(savedata);

        this.counter.v = savedata.v;
        for (let i in ITEMS) {
            if (i >= savedata.items.length) break;

            ITEMS[i].cost = savedata.items[i].cost;
            ITEMS[i].lvl = savedata.items[i].lvl;
            ITEMS[i].value = savedata.items[i].value;
        }

        this.reloading = false;
    }

    saveGame() {
        let items = [];
        for (let i in ITEMS) {
            items[i] = {
                cost: ITEMS[i].cost,
                lvl: ITEMS[i].lvl,
                value: ITEMS[i].value
            };
        }

        let savedata = {
            empty: false,
            v: this.counter.v,
            items: items
        };

        if (!this.reloading)
            window.localStorage.setItem("spacebar_clicker_game", JSON.stringify(savedata));
    }
    
    // Particles
    addPointParticle(x, y, val) {
        let element = document.createElement('div');
        element.textContent = "+" + val;
        element.classList.add("particle");45
        element.classList.add("score");
        let xr = (Math.random() * 30) - 30;
        let yr = (Math.random() * 30) - 20;
        this.click_particle.pushParticle(element, { x: x + xr, y: y + yr });
        document.body.insertBefore(element, document.body.firstChild);
    }

    // Effects
    shake(val = 20, el = undefined) {
        if (el == undefined) el = gId("game");
        co(function*() {
            for (let i = 0; i < val; i++) {
                let x = (Math.random() * 30) - 15;
                let y = (Math.random() * 30) - 15;
                let z = (Math.random() * 6) - 3;
                el.style['transform'] = "translateX(" + x + "px) translateY(" + y + "px) rotateZ(" + z + "deg)";
                yield .01;
            }
            el.style['transform'] = "translateX(0px) translateY(0px) rotateZ(0deg)";
        });
    }
}

</script>
        <script>
let game = new Game();

(function() {
    game.init();
})();
</script>
</body>
</html>